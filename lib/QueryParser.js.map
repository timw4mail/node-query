{"version":3,"sources":["QueryParser.js"],"names":[],"mappings":"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","file":"QueryParser.js","sourcesContent":["'use strict';\n\nimport helpers from './helpers';\n\n\n// --------------------------------------------------------------------------\n\n/**\n * @constructor\n * @param {Driver} - The driver object for the database in use\n * @module query-parser\n */\nmodule.exports = class QueryParser {\n\t/**\n\t * @constructor\n\t * @param {Driver} - The driver object for the database in use\n\t * @return {void}\n\t */\n\tconstructor(driver) {\n\t\tthis.driver = driver;\n\n\t\tlet matchPatterns = {\n\t\t\t'function': /([a-z0-9_]+\\((.*)\\))/i,\n\t\t\toperator: /\\!=?|\\=|\\+|&&?|~|\\|\\|?|\\^|\\/|<>|>=?|<=?|\\-|%|OR|AND|NOT|XOR/ig,\n\t\t\tliteral: /([0-9]+)|'(.*?)'|true|false/ig\n\t\t};\n\n\t\t// Full pattern for identifiers\n\t\t// Making sure that literals and functions aren't matched\n\t\tmatchPatterns.identifier = new RegExp(\n\t\t\t'('\n\t\t\t\t+ '(?!'\n\t\t\t\t\t+ matchPatterns['function'].source + '|'\n\t\t\t\t\t+ matchPatterns.literal.source\n\t\t\t\t+ ')'\n\t\t\t\t+ '([a-z_\\-]+[0-9]*\\\\.?)'\n\t\t\t+ ')+'\n\t\t, 'ig');\n\n\t\t// Full pattern for determining ordering of the pieces\n\t\tmatchPatterns.joinCombined = new RegExp(\n\t\t\tmatchPatterns['function'].source + \"+|\"\n\t\t\t+ matchPatterns.literal.source + '+|'\n\t\t\t+ matchPatterns.identifier.source\n\t\t\t+ '|(' + matchPatterns.operator.source + ')+'\n\t\t, 'ig');\n\n\t\tthis.matchPatterns = matchPatterns;\n\t\tthis.identifierBlacklist = ['true','false','null'];\n\t}\n\n\t/**\n\t * Filter matched patterns\n\t *\n\t * @param {Array} array\n\t * @return {Array|null}\n\t */\n\tfilterMatches(array) {\n\t\tlet output = [];\n\n\t\t// Return non-array matches\n\t\tif (helpers.isNull(array)) return null;\n\t\tif (helpers.isScalar(array) || helpers.isUndefined(array)) return output;\n\n\t\tarray.forEach((item) => {\n\t\t\toutput.push(item);\n\t\t});\n\t\treturn output;\n\t}\n\n\t/**\n\t * Check if the string contains an operator, and if so, return the operator(s).\n\t * If there are no matches, return null\n\t *\n\t * @param {String} string - the string to check\n\t * @return {Array|null}\n\t */\n\thasOperator(string) {\n\t\treturn this.filterMatches(string.match(this.matchPatterns.operator));\n\t}\n\n\t/**\n\t * Tokenize the sql into parts for additional processing\n\t *\n\t * @param {String} sql\n\t * @return {Object}\n\t */\n\tparseJoin(sql) {\n\t\tlet matches = {};\n\t\tlet output = {\n\t\t\tfunctions: [],\n\t\t\tidentifiers: [],\n\t\t\toperators: [],\n\t\t\tliterals: []\n\t\t};\n\n\t\t// Get clause components\n\t\tmatches.functions = sql.match(new RegExp(this.matchPatterns['function'].source, 'ig'));\n\t\tmatches.identifiers = sql.match(this.matchPatterns.identifier);\n\t\tmatches.operators = sql.match(this.matchPatterns.operator);\n\t\tmatches.literals = sql.match(this.matchPatterns.literal);\n\n\t\t// Get everything at once for ordering\n\t\tmatches.combined = sql.match(this.matchPatterns.joinCombined);\n\n\t\t// Flatten the matches to increase relevance\n\t\tObject.keys(matches).forEach((key) => {\n\t\t\toutput[key] = this.filterMatches(matches[key]);\n\t\t});\n\n\t\treturn output;\n\t}\n\n\t/**\n\t * Return the output of the parsing of the join condition\n\t *\n\t * @param {String} condition - The join condition to evalate\n\t * @return {String} - The parsed/escaped join condition\n\t */\n\tcompileJoin(condition) {\n\t\tlet parts = this.parseJoin(condition);\n\t\tlet count = parts.identifiers.length;\n\t\tlet i;\n\n\t\t// Quote the identifiers\n\t\tparts.combined.forEach((part, i) => {\n\t\t\tif (parts.identifiers.indexOf(part) !== -1 && ! helpers.isNumber(part))\n\t\t\t{\n\t\t\t\tparts.combined[i] = this.driver.quoteIdentifiers(part);\n\t\t\t}\n\t\t});\n\n\t\treturn parts.combined.join(' ');\n\t}\n\n\t/**\n\t * Parse a where clause to separate functions from values\n\t *\n\t * @param {Driver} driver\n\t * @param {State} state\n\t * @return {String} - The parsed/escaped where condition\n\t */\n\tparseWhere(driver, state) {\n\t\tlet whereMap = state.whereMap;\n\t\tlet\twhereValues = state.rawWhereValues;\n\n\t\tlet outputMap = [];\n\t\tlet outputValues = [];\n\n\t\tObject.keys(whereMap).forEach((key) => {\n\t\t\t// Combine fields, operators, functions and values into a full clause\n\t\t\t// to have a common starting flow\n\t\t\tlet fullClause = '';\n\n\t\t\t// Add an explicit = sign where one is inferred\n\t\t\tif ( ! this.hasOperator(key))\n\t\t\t{\n\t\t\t\tfullClause = key + ' = ' + whereMap[key];\n\t\t\t}\n\t\t\telse if (whereMap[key] === key)\n\t\t\t{\n\t\t\t\tfullClause = key;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tfullClause = key + ' ' + whereMap[key];\n\t\t\t}\n\n\t\t\t// Separate the clause into separate pieces\n\t\t\tlet parts = this.parseJoin(fullClause);\n\n\t\t\t// Filter explicit literals from lists of matches\n\t\t\tif (whereValues.indexOf(whereMap[key]) !== -1)\n\t\t\t{\n\t\t\t\tlet value = whereMap[key];\n\t\t\t\tlet identIndex = (helpers.isArray(parts.identifiers)) ? parts.identifiers.indexOf(value) : -1;\n\t\t\t\tlet litIndex = (helpers.isArray(parts.literals)) ? parts.literals.indexOf(value) : -1;\n\t\t\t\tlet combIndex = (helpers.isArray(parts.combined)) ? parts.combined.indexOf(value) : -1;\n\t\t\t\tlet funcIndex = (helpers.isArray(parts.functions)) ? parts.functions.indexOf(value) : -1;\n\t\t\t\tlet inOutputArray = outputValues.indexOf(value) !== -1;\n\n\t\t\t\t// Remove the identifier in question,\n\t\t\t\t// and add to the output values array\n\t\t\t\tif (identIndex !== -1)\n\t\t\t\t{\n\t\t\t\t\tparts.identifiers.splice(identIndex, 1);\n\n\t\t\t\t\tif ( ! inOutputArray)\n\t\t\t\t\t{\n\t\t\t\t\t\toutputValues.push(value);\n\t\t\t\t\t\tinOutputArray = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Remove the value from the literals list\n\t\t\t\t// so it is not added twice\n\t\t\t\tif (litIndex !== -1)\n\t\t\t\t{\n\t\t\t\t\tparts.literals.splice(litIndex, 1);\n\n\t\t\t\t\tif ( ! inOutputArray)\n\t\t\t\t\t{\n\t\t\t\t\t\toutputValues.push(value);\n\t\t\t\t\t\tinOutputArray = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Remove the value from the combined list\n\t\t\t\t// and replace it with a placeholder\n\t\t\t\tif (combIndex !== -1)\n\t\t\t\t{\n\t\t\t\t\t// Make sure to skip functions when replacing values\n\t\t\t\t\tif (funcIndex === -1)\n\t\t\t\t\t{\n\t\t\t\t\t\tparts.combined[combIndex] = '?';\n\n\t\t\t\t\t\tif ( ! inOutputArray)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\toutputValues.push(value);\n\t\t\t\t\t\t\tinOutputArray = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Filter false positive identifiers\n\t\t\tparts.identifiers = parts.identifiers || [];\n\t\t\tparts.identifiers = parts.identifiers.filter((item) => {\n\t\t\t\tlet isInCombinedMatches = parts.combined.indexOf(item) !== -1;\n\t\t\t\tlet isNotInBlackList = this.identifierBlacklist.indexOf(item.toLowerCase()) === -1;\n\n\t\t\t\treturn isInCombinedMatches && isNotInBlackList;\n\t\t\t}, this);\n\n\t\t\t// Quote identifiers\n\t\t\tif (helpers.isArray(parts.identifiers))\n\t\t\t{\n\t\t\t\tparts.identifiers.forEach((ident) => {\n\t\t\t\t\tlet index = parts.combined.indexOf(ident);\n\t\t\t\t\tif (index !== -1)\n\t\t\t\t\t{\n\t\t\t\t\t\tparts.combined[index] = driver.quoteIdentifiers(ident);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\n\t\t\t// Replace each literal with a placeholder in the map\n\t\t\t// and add the literal to the values,\n\t\t\t// This should only apply to literal values that are not\n\t\t\t// explicitly mapped to values, but have to be parsed from\n\t\t\t// a where condition,\n\t\t\tif (helpers.isArray(parts.literals))\n\t\t\t{\n\t\t\t\tparts.literals.forEach((lit) => {\n\t\t\t\t\tlet litIndex = parts.combined.indexOf(lit);\n\n\t\t\t\t\tif (litIndex !== -1)\n\t\t\t\t\t{\n\t\t\t\t\t\tparts.combined[litIndex] = (helpers.isArray(parts.operators)) ? '?' : '= ?';\n\t\t\t\t\t\toutputValues.push(lit);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\n\t\t\toutputMap.push(parts.combined.join(' '));\n\t\t});\n\n\t\tstate.rawWhereValues = [];\n\t\tstate.whereValues = state.whereValues.concat(outputValues);\n\t\tstate.whereMap = outputMap;\n\n\t\treturn state;\n\t}\n}"],"sourceRoot":"/source/"}
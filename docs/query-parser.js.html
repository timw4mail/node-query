<!DOCTYPE html>

<html lang="en">
<head>
	<meta charset="utf-8">
	<title>DocStrap Source: query-parser.js</title>

	<!--[if lt IE 9]>
	<script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
	<![endif]-->
	<link type="text/css" rel="stylesheet" href="styles/sunlight.default.css">

	<link type="text/css" rel="stylesheet" href="styles/site.cosmo.css">

</head>

<body>
<div class="container-fluid">
	<div class="navbar navbar-fixed-top navbar-inverse">
		<div class="navbar-inner">
			<a class="brand" href="index.html">DocStrap</a>
			<ul class="nav">
				
				<li class="dropdown">
					<a href="modules.list.html" class="dropdown-toggle" data-toggle="dropdown">Modules<b
						class="caret"></b></a>

					<ul class="dropdown-menu ">
						
						<li>
							<a href="module-adapter.html">adapter</a>
						</li>
						
						<li>
							<a href="module-driver.html">driver</a>
						</li>
						
						<li>
							<a href="module-helpers.html">helpers</a>
						</li>
						
						<li>
							<a href="module-node-query.html">node-query</a>
						</li>
						
						<li>
							<a href="module-query-builder.html">query-builder</a>
						</li>
						
						<li>
							<a href="module-query-parser.html">query-parser</a>
						</li>
						
						<li>
							<a href="module-State.html">State</a>
						</li>
						

					</ul>
				</li>
				
			</ul>
		</div>
	</div>

	<div class="row-fluid">

		
			<div class="span12">
				
				<div id="main">
					


		<h1 class="page-title">Source: query-parser.js</h1>
    
<section>
	<article>
		<pre
			class="sunlight-highlight-javascript linenums">'use strict';

var helpers = require('./helpers');

var matchPatterns = {
	'function': /([a-z0-9_]+\((.*)\))/i,
	operator: /\!=?|\=|\+|&amp;&amp;?|~|\|\|?|\^|\/|&lt;>|>=?|&lt;=?|\-|%|OR|AND|NOT|XOR/ig,
	literal: /([0-9]+)|'(.*?)'|true|false/ig
};

// Full pattern for identifiers
// Making sure that literals and functions aren't matched
matchPatterns.identifier = new RegExp(
	'('
		+ '(?!'
			+ matchPatterns['function'].source + '|'
			+ matchPatterns.literal.source
		+ ')'
		+ '([a-z_\-]+[0-9]*\\.?)'
	+ ')+'
, 'ig');

// Full pattern for determining ordering of the pieces
matchPatterns.joinCombined = new RegExp(
	matchPatterns['function'].source + "+|"
	+ matchPatterns.literal.source + '+|'
	+ matchPatterns.identifier.source
	+ '|(' + matchPatterns.operator.source + ')+'
, 'ig');

var identifierBlacklist = ['true','false','null'];

var filterMatches = function(array) {
	var output = [];

	// Return non-array matches
	if (helpers.isNull(array)) return null;
	if (helpers.isScalar(array) || helpers.isUndefined(array)) return output;

	array.forEach(function(item) {
		output.push(item);
	});

	return output;
};

// --------------------------------------------------------------------------

/**
 * @constructor
 * @param {Driver} - The driver object for the database in use
 * @module query-parser
 */
var QueryParser = function(driver) {

	// That 'new' keyword is annoying
	if ( ! (this instanceof QueryParser)) return new QueryParser(driver);

	/**
	 * Check if the string contains an operator, and if so, return the operator(s).
	 * If there are no matches, return null
	 *
	 * @param {String} string - the string to check
	 * @return {Array|null}
	 */
	this.hasOperator = function(string) {
		return filterMatches(string.match(matchPatterns.operator));
	}

	/**
	 * Tokenize the sql into parts for additional processing
	 *
	 * @param {String} sql
	 * @return {Object}
	 */
	this.parseJoin = function(sql) {
		var matches = {};
		var output = {};

		// Get clause components
		matches.functions = sql.match(new RegExp(matchPatterns['function'].source, 'ig'));
		matches.identifiers = sql.match(matchPatterns.identifier);
		matches.operators = sql.match(matchPatterns.operator);
		matches.literals = sql.match(matchPatterns.literal);

		// Get everything at once for ordering
		matches.combined = sql.match(matchPatterns.joinCombined);

		// Flatten the matches to increase relevance
		Object.keys(matches).forEach(function(key) {
			output[key] = filterMatches(matches[key]);
		});

		return output;
	};

	/**
	 * Return the output of the parsing of the join condition
	 *
	 * @param {String} condition - The join condition to evalate
	 * @return {String} - The parsed/escaped join condition
	 */
	this.compileJoin = function(condition) {
		var parts = this.parseJoin(condition);
		var count = parts.identifiers.length;
		var i;

		// Quote the identifiers
		parts.combined.forEach(function(part, i) {
			if (parts.identifiers.indexOf(part) !== -1 &amp;&amp; ! helpers.isNumber(part))
			{
				parts.combined[i] = driver.quoteIdentifiers(part);
			}
		});

		return parts.combined.join(' ');
	};

	/**
	 * Parse a where clause to separate functions from values
	 *
	 * @param {Object} driver
	 * @param {State} state
	 * @return {String} - The parsed/escaped where condition
	 */
	this.parseWhere = function(driver, state) {
		var whereMap = state.whereMap,
			whereValues = state.rawWhereValues;

		var outputMap = [];
		var outputValues = [];

		Object.keys(whereMap).forEach(function(key) {
			// Combine fields, operators, functions and values into a full clause
			// to have a common starting flow
			var fullClause = '';

			// Add an explicit = sign where one is inferred
			if ( ! this.hasOperator(key))
			{
				fullClause = key + ' = ' + whereMap[key];
			}
			else if (whereMap[key] === key)
			{
				fullClause = key;
			}
			else
			{
				fullClause = key + ' ' + whereMap[key];
			}

			// Separate the clause into separate pieces
			var parts = this.parseJoin(fullClause);

			// Filter explicit literals from lists of matches
			if (whereValues.indexOf(whereMap[key]) !== -1)
			{
				var value = whereMap[key];
				var identIndex = (helpers.isArray(parts.identifiers)) ? parts.identifiers.indexOf(value) : -1;
				var litIndex = (helpers.isArray(parts.literals)) ? parts.literals.indexOf(value) : -1;
				var combIndex = (helpers.isArray(parts.combined)) ? parts.combined.indexOf(value) : -1;
				var funcIndex = (helpers.isArray(parts.functions)) ? parts.functions.indexOf(value) : -1;
				var inOutputArray = outputValues.indexOf(value) !== -1;

				// Remove the identifier in question,
				// and add to the output values array
				if (identIndex !== -1)
				{
					parts.identifiers.splice(identIndex, 1);

					if ( ! inOutputArray)
					{
						outputValues.push(value);
						inOutputArray = true;
					}
				}

				// Remove the value from the literals list
				// so it is not added twice
				if (litIndex !== -1)
				{
					parts.literals.splice(litIndex, 1);

					if ( ! inOutputArray)
					{
						outputValues.push(value);
						inOutputArray = true;
					}
				}

				// Remove the value from the combined list
				// and replace it with a placeholder
				if (combIndex !== -1)
				{
					// Make sure to skip functions when replacing values
					if (funcIndex === -1)
					{
						parts.combined[combIndex] = '?';

						if ( ! inOutputArray)
						{
							outputValues.push(value);
							inOutputArray = true;
						}
					}
				}
			}

			// Filter false positive identifiers
			parts.identifiers = parts.identifiers.filter(function(item) {
				var isInCombinedMatches = parts.combined.indexOf(item) !== -1;
				var isNotInBlackList = identifierBlacklist.indexOf(item.toLowerCase()) === -1;

				return isInCombinedMatches &amp;&amp; isNotInBlackList;
			});

			// Quote identifiers
			if (helpers.isArray(parts.identifiers))
			{
				parts.identifiers.forEach(function(ident) {
					var index = parts.combined.indexOf(ident);
					if (index !== -1)
					{
						parts.combined[index] = driver.quoteIdentifiers(ident);
					}
				});
			}

			// Replace each literal with a placeholder in the map
			// and add the literal to the values,
			// This should only apply to literal values that are not
			// explicitly mapped to values, but have to be parsed from
			// a where condition,
			if (helpers.isArray(parts.literals))
			{
				parts.literals.forEach(function(lit) {
					var litIndex = parts.combined.indexOf(lit);

					if (litIndex !== -1)
					{
						parts.combined[litIndex] = (helpers.isArray(parts.operators)) ? '?' : '= ?';
						outputValues.push(lit);
					}
				});
			}

			outputMap.push(parts.combined.join(' '));
		}, this);

		state.rawWhereValues = [];
		state.whereValues = state.whereValues.concat(outputValues);
		state.whereMap = outputMap;

		return state;
	};
};

module.exports = QueryParser;</pre>
	</article>
</section>





				</div>

				<div class="clearfix"></div>
				<footer>
					
					
		<span class="copyright">
		DocStrap Copyright Â© 2012-2014 The contributors to the JSDoc3 and DocStrap projects.
		</span>
					<br />
					
		<span class="jsdoc-message">
		Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.3.0-alpha9</a>
		on Tue Jan 27th 2015 using the <a
			href="https://github.com/terryweiss/docstrap">DocStrap template</a>.
		</span>
				</footer>
			</div>

			
			<br clear="both">
		</div>

	</div>
	<!--<script src="scripts/sunlight.js"></script>-->
	<script src="scripts/docstrap.lib.js"></script>
	<script src="scripts/bootstrap-dropdown.js"></script>
	<script src="scripts/toc.js"></script>

	<script>
		$( function () {
			$( "[id*='$']" ).each( function () {
				var $this = $( this );

				$this.attr( "id", $this.attr( "id" ).replace( "$", "__" ) );
			} );

			$( "#toc" ).toc( {
				anchorName  : function ( i, heading, prefix ) {
					return $( heading ).attr( "id" ) || ( prefix + i );
				},
				selectors   : "h1,h2,h3,h4",
				showAndHide : false,
				scrollTo    : "100px"
			} );

			$( "#toc>ul" ).addClass( "nav nav-pills nav-stacked" );
			$( "#main span[id^='toc']" ).addClass( "toc-shim" );
			$( '.dropdown-toggle' ).dropdown();
//			$( ".tutorial-section pre, .readme-section pre" ).addClass( "sunlight-highlight-javascript" ).addClass( "linenums" );

			$( ".tutorial-section pre, .readme-section pre" ).each( function () {
				var $this = $( this );

				var example = $this.find( "code" );
				exampleText = example.html();
				var lang = /{@lang (.*?)}/.exec( exampleText );
				if ( lang && lang[1] ) {
					exampleText = exampleText.replace( lang[0], "" );
					example.html( exampleText );
					lang = lang[1];
				} else {
					lang = "javascript";
				}

				if ( lang ) {

					$this
						.addClass( "sunlight-highlight-" + lang )
						.addClass( "linenums" )
						.html( example.html() );

				}
			} );

			Sunlight.highlightAll( {
				lineNumbers : true,
				showMenu : true,
				enableDoclinks : true
			} );
		} );
	 </script>



	<!--Navigation and Symbol Display-->
	


	<!--Google Analytics-->
	

</body>
</html>
